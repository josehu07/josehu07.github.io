(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var bitaggy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bitaggy */ \"./node_modules/bitaggy/bitaggy.js\");\n/* harmony import */ var bitaggy_bitaggy_bg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bitaggy/bitaggy_bg */ \"./node_modules/bitaggy/bitaggy_bg.wasm\");\n\n\n\n\n// Cell display settings.\nconst CELL_SIZE = 12;    // px\nconst GRID_COLOR = \"#CCCCCC\";\nconst DEAD_COLOR = \"#FFFFFF\";\nconst ALIVE_COLOR = \"#000000\";\n\n// Construct the universe, get its width and height.\nconst universe = bitaggy__WEBPACK_IMPORTED_MODULE_0__[\"Universe\"].new(42, 42, false);\nconst width = universe.width();\nconst height = universe.height();\n\n// Give the canvas room for all of our cells and a 1px border\n// around each of them.\nconst canvas = document.getElementById(\"game-of-life-canvas\");\ncanvas.width = (CELL_SIZE + 1) * width + 1;\ncanvas.height = (CELL_SIZE + 1) * height + 1;\nconst ctx = canvas.getContext('2d');\n\nfunction getIndex(row, col) {\n    return row * width + col;\n}\n\nfunction bitIsSet(arr, idx) {\n    const byte = Math.floor(idx / 8);\n    const mask = 1 << (idx % 8);\n    return (arr[byte] & mask) === mask;\n}\n\n// Draws the cells.\nfunction drawCells() {\n    const cellsPtr = universe.cells();\n    const cells = new Uint8Array(bitaggy_bitaggy_bg__WEBPACK_IMPORTED_MODULE_1__[\"memory\"].buffer, cellsPtr, width * height / 8);\n\n    ctx.beginPath();\n\n    for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n            const idx = getIndex(row, col);\n            ctx.fillStyle = bitIsSet(cells, idx)\n                ? ALIVE_COLOR\n                : DEAD_COLOR;\n            ctx.fillRect(\n                col * (CELL_SIZE + 1) + 1,\n                row * (CELL_SIZE + 1) + 1,\n                CELL_SIZE,\n                CELL_SIZE\n            );\n        }\n    }\n\n    ctx.stroke();\n}\n\n// Draws the drid between cells.\nfunction drawGrid() {\n    ctx.beginPath();\n    ctx.strokeStyle = GRID_COLOR;\n\n    // Vertical lines.\n    for (let i = 0; i <= width; i++) {\n        ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);\n        ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);\n    }\n\n    // Horizontal lines.\n    for (let j = 0; j <= height; j++) {\n        ctx.moveTo(0,                           j * (CELL_SIZE + 1) + 1);\n        ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);\n    }\n\n    ctx.stroke();\n}\n\n\n// Start/pause button control.\nconst playButton = document.getElementById(\"play-pause-btn\");\nconst buttonStartText = \"▶️ Start\";\nconst buttonPauseText = \"⏸ Pause\";\nplayButton.textContent = buttonStartText;\n\nlet animationId = null;\nlet paused = true;\n\nfunction play() {\n    playButton.textContent = buttonPauseText;\n    paused = false;\n    renderLoop();\n}\n\nfunction pause() {\n    playButton.textContent = buttonStartText;\n    paused = true;\n    if (animationId != null) {\n        cancelAnimationFrame(animationId);\n    }\n}\n\nplayButton.addEventListener(\"click\", event => {\n    if (paused) {\n        play();\n    } else {\n        pause();\n    }\n});\n\n\n// Reset button control.\nconst resetButton = document.getElementById(\"reset-btn\");\nresetButton.textContent = \"🔄 Reset\";\n\nfunction reset(rand_init) {\n    universe.reset(rand_init);\n    // drawGrid();\n    drawCells();\n}\n\nresetButton.addEventListener(\"click\", event => {\n    pause();\n    reset(false);\n});\n\n\n// Randomization button control.\nconst randomButton = document.getElementById(\"random-btn\");\nrandomButton.textContent = \"🔀 Random\"\n\nrandomButton.addEventListener(\"click\", event => {\n    pause();\n    reset(true);\n});\n\n\n// Mouse click toggling support.\ncanvas.addEventListener(\"click\", event => {\n    if (paused) {\n        const boundingRect = canvas.getBoundingClientRect();\n        const scaleX = canvas.width / boundingRect.width;\n        const scaleY = canvas.height / boundingRect.height;\n        const canvasLeft = (event.clientX - boundingRect.left) * scaleX;\n        const canvasTop = (event.clientY - boundingRect.top) * scaleY;\n        const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), height - 1);\n        const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), width - 1);\n    \n        universe.toggle(row, col);\n        // drawGrid();\n        drawCells();\n    }\n});\n\n\n// Renders next tick of universe in desired FPS rate.\nconst FPS = 5;\nconst FPS_INTERVAL = 1000 / FPS;\nvar last_draw_time = Date.now();\n\nfunction renderLoop() {\n    let now = Date.now();\n    let elapsed = now - last_draw_time;\n\n    if (!paused) {\n        if (elapsed > FPS_INTERVAL) {\n            last_draw_time = now - (elapsed % FPS_INTERVAL);\n            \n            universe.tick();\n            // drawGrid();\n            drawCells();\n        }\n        \n        requestAnimationFrame(renderLoop);\n    }\n}\n\nwindow.onload = () => {\n    drawGrid();\n    drawCells();\n    requestAnimationFrame(renderLoop);\n}\n\ndrawGrid();\ndrawCells();\nrequestAnimationFrame(renderLoop);\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ })

}]);